use serde_json::{Value, map};
use std::{env, io::{self, Write}, process};
use failure::{bail};

type Map = map::Map<String, Value>;

type Result<T> = std::result::Result<T, failure::Error>;

fn download<F>(uri: &str, mut action: F, debug: bool) -> Result<()>
where
    F: FnMut(Map) -> Result<()>
{
    let json: Value = reqwest::get(uri)?.json()?;
    let json = if let Value::Object(m) = json {
        m
    } else {
        bail!("Malformed JSON: {:?}", json)
    };

    if debug {
        writeln!(io::stderr(), "#json == {}", json.len())?;
        writeln!(io::stderr(), "License list version {}", get(&json, "licenseListVersion")?)?;
    }

    action(json)
}

fn get<'a>(m: &'a Map, k: &str) -> Result<&'a Value> {
    m.get(k).ok_or_else(|| failure::format_err!("Malformed JSON: {:?} lacks {}", m, k))
}

const IS_FSF_LIBRE: u8 = 0x1;
const IS_OSI_APPROVED: u8 = 0x2;
const IS_DEPRECATED: u8 = 0x4;

fn real_main() -> Result<()> {
    let mut upstream_tag = None;
    let mut debug = false;
    for e in env::args().skip(1) {
        match e.as_str() {
            "-d" => {
                debug = true;
            },
            s if s.starts_with('v') => {
                upstream_tag = Some(s.to_owned())
            },
            _ => {
                bail!("Unknown option {:?}", e)
            }
        }
    }

    let mut stdout = io::stdout();
    let mut stderr = io::stderr();

    let upstream_tag = match upstream_tag {
        None => {
            writeln!(stderr, "WARN: fetching data from the master branch of spdx/license-list-data; \
                                consider specifying a tag (e.g. v3.0)")?;

            "master".to_owned()
        }
        Some(ut) => {
            if debug {
                writeln!(stderr, "Using tag {:?}", ut)?;
            }
            ut
        }
    };

    writeln!(stdout, "\
/*
 * list fetched from https://github.com/spdx/license-list-data @ {}
 *
 * AUTO-GENERATED BY ./update
 * DO NOT MODIFY
 *
 * cargo run --manifest-path update/Cargo.toml -- v<version> > src/identifiers.rs
 */
", upstream_tag)?;

    let licenses_json_uri =
        format!("https://raw.githubusercontent.com/spdx/license-list-data/{}/json/licenses.json",
                upstream_tag);

    download(&licenses_json_uri, |json| {
        let licenses = get(&json, "licenses")?;
        let licenses = if let Value::Array(ref v) = licenses {
            v
        } else {
            bail!("Malformed JSON: {:?}", licenses)
        };
        writeln!(stderr, "#licenses == {}", licenses.len())?;

        let mut v = vec![];
        for lic in licenses.iter() {
            let lic = if let Value::Object(ref m) = *lic {
                m
            } else {
                bail!("Malformed JSON: {:?}", lic)
            };
            if debug {
                writeln!(stderr, "{:?},{:?}", get(&lic, "licenseId"), get(&lic, "name"))?;
            }

            let lic_id = get(&lic, "licenseId")?;
            if let Value::String(ref s) = lic_id {
                let mut flags = 0;

                if let Ok(Value::Bool(val)) = get(&lic, "isDeprecatedLicenseId") {
                    if *val {
                        flags |= IS_DEPRECATED;
                    }
                }

                if let Ok(Value::Bool(val)) = get(&lic, "isOsiApproved") {
                    if *val {
                        flags |= IS_OSI_APPROVED;
                    }
                }

                if let Ok(Value::Bool(val)) = get(&lic, "isFsfLibre") {
                    if *val {
                        flags |= IS_FSF_LIBRE;
                    }
                }

                v.push((s, flags));
            } else {
                bail!("Malformed JSON: {:?}", lic_id);
            }
        }
        v.sort_by_key(|v| v.0);

        let lic_list_ver = get(&json, "licenseListVersion")?;
        if let Value::String(ref s) = lic_list_ver {
            writeln!(stdout, "pub const VERSION: &str = {:?};", s)?;
        } else {
            bail!("Malformed JSON: {:?}", lic_list_ver)
        }
        writeln!(stdout)?;
        writeln!(stdout, "pub const LICENSES: &[(&str, u8)] = &[")?;
        for (lic, flags) in v.iter() {
            writeln!(stdout, "    (\"{}\", {}),", lic, flags)?;
        }
        writeln!(stdout, "];")?;

        Ok(())
    }, debug)?;

    writeln!(stdout)?;

    let exceptions_json_uri =
        format!("https://raw.githubusercontent.com/spdx/license-list-data/{}/json/exceptions.json",
                upstream_tag);
    download(&exceptions_json_uri, |json| {
        let exceptions = get(&json, "exceptions")?;
        let exceptions = if let Value::Array(ref v) = exceptions {
            v
        } else {
            bail!("Malformed JSON: {:?}", exceptions)
        };
        writeln!(stderr, "#exceptions == {}", exceptions.len())?;

        let mut v = vec![];
        for exc in exceptions.iter() {
            let exc = if let Value::Object(ref m) = *exc {
                m
            } else {
                bail!("Malformed JSON: {:?}", exc)
            };
            if debug {
                writeln!(stderr, "{:?},{:?}", get(&exc, "licenseExceptionId"), get(&exc, "name"))?;
            }

            let lic_exc_id = get(&exc, "licenseExceptionId")?;
            if let Value::String(ref s) = lic_exc_id {
                let flags = match get(&exc, "isDeprecatedLicenseId") {
                    Ok(Value::Bool(val)) => if *val { IS_DEPRECATED } else { 0 },
                    _ => 0
                };

                v.push((s, flags));
            } else {
                bail!("Malformed JSON: {:?}", lic_exc_id)
            };
        }

        writeln!(stdout, "pub const EXCEPTIONS: &[(&str, u8)] = &[")?;
        v.sort_by_key(|v| v.0);
        for (exc, flags) in v.iter() {
            writeln!(stdout, "    (\"{}\", {}),", exc, flags)?;
        }
        writeln!(stdout, "];")?;

        Ok(())
    }, debug)?;

    Ok(())
}

fn main() {
    if let Err(ref e) = real_main() {
        eprintln!("error: {}", e);
        process::exit(1);
    }
}
